import * as i0 from '@angular/core';
import { Injectable, Directive, Input, HostListener, EventEmitter, Component, ChangeDetectionStrategy, ViewChildren, Output, NgModule } from '@angular/core';
import * as i2 from '@angular/forms';
import { UntypedFormArray, UntypedFormControl, Validators, ReactiveFormsModule, FormsModule } from '@angular/forms';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';

var NgxOtpBehavior;
(function (NgxOtpBehavior) {
    NgxOtpBehavior[NgxOtpBehavior["DEFAULT"] = 0] = "DEFAULT";
    NgxOtpBehavior[NgxOtpBehavior["LEGACY"] = 1] = "LEGACY";
})(NgxOtpBehavior || (NgxOtpBehavior = {}));

class NgxOtpInputService {
    init2DArray(size) {
        return new Array(size).fill(new Array());
    }
    toArray(value) {
        return Array.isArray(value) ? value : [value];
    }
    addItemToAll(source, items) {
        if ((source === null || source === void 0 ? void 0 : source.length) > 0) {
            return source.map((entry) => entry.concat(items));
        }
    }
    removeItemFromAll(source, items) {
        if ((source === null || source === void 0 ? void 0 : source.length) > 0) {
            return source.map((entry) => entry.filter((item) => !items.includes(item)));
        }
    }
    addItemAtIndex(source, index, items) {
        if ((source === null || source === void 0 ? void 0 : source.length) > 0) {
            source[index] = source[index].concat(items);
            return source;
        }
    }
    removeItemAtIndex(source, index, items) {
        if ((source === null || source === void 0 ? void 0 : source.length) > 0) {
            source[index] = source[index].filter((item) => !items.includes(item));
            return source;
        }
    }
}
NgxOtpInputService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NgxOtpInputService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputService, decorators: [{
            type: Injectable
        }] });

class PatternDirective {
    constructor() {
        // allowed keys apart from numeric characters
        this.allowedKeys = [
            'Backspace',
            'ArrowLeft',
            'ArrowRight',
            'Escape',
            'Tab',
        ];
    }
    onKeyDown(e) {
        if (this.allowedKeys.includes(e.key) ||
            (e.code === 'KeyA' && e.ctrlKey === true) || // Allow: Ctrl+A
            (e.code === 'KeyC' && e.ctrlKey === true) || // Allow: Ctrl+C
            (e.code === 'KeyV' && e.ctrlKey === true) || // Allow: Ctrl+V
            (e.code === 'KeyX' && e.ctrlKey === true) || // Allow: Ctrl+X
            (e.code === 'KeyA' && e.metaKey === true) || // Cmd+A (Mac)
            (e.code === 'KeyC' && e.metaKey === true) || // Cmd+C (Mac)
            (e.code === 'KeyV' && e.metaKey === true) || // Cmd+V (Mac)
            (e.code === 'KeyX' && e.metaKey === true) // Cmd+X (Mac)
        ) {
            return; // let it happen, don't do anything
        }
        else if (!this.pattern.test(e.key)) {
            e.preventDefault();
        }
    }
}
PatternDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: PatternDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
PatternDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.1", type: PatternDirective, selector: "[ngxOtpPattern]", inputs: { pattern: ["ngxOtpPattern", "pattern"] }, host: { listeners: { "keydown": "onKeyDown($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: PatternDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxOtpPattern]',
                }]
        }], propDecorators: { pattern: [{
                type: Input,
                args: ['ngxOtpPattern']
            }], onKeyDown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

class NgxOtpInputComponent {
    constructor(ngxOtpInputService, ref) {
        this.ngxOtpInputService = ngxOtpInputService;
        this.ref = ref;
        this.ngxOtpArray = new UntypedFormArray([]);
        this.ariaLabels = [];
        this.styles = [];
        this.otpConfig = {
            otpLength: 6,
            autofocus: true,
            autoblur: true,
            behavior: NgxOtpBehavior.DEFAULT,
        };
        this.defaultPattern = /^\d+$/;
        this.DEFAULT_ARIA_LABEL = 'One time password input';
        this.isNgxOtpArrayDisabled = false;
        this.focusedInputHasValue = false;
        this.otpChange = new EventEmitter();
        this.fill = new EventEmitter();
    }
    onPaste(event) {
        event.preventDefault();
        this.handlePaste(event.clipboardData.getData('text'));
    }
    set disable(isDisabled) {
        this.handleDisable(isDisabled);
        this.isNgxOtpArrayDisabled = isDisabled;
    }
    set config(c) {
        var _a;
        this.otpConfig = Object.assign(Object.assign({}, this.otpConfig), c);
        if ((_a = this.otpConfig.classList) === null || _a === void 0 ? void 0 : _a.input) {
            this.setInitialStyles();
        }
        if (!c.pattern) {
            this.otpConfig.pattern = this.defaultPattern;
        }
    }
    set status(status) {
        this.handleStatusChange(status);
    }
    ngOnInit() {
        this.setUpOtpForm();
        this.setUpAriaLabels();
        this.LAST_INPUT_INDEX = this.otpConfig.otpLength - 1;
        this.otpFormChangeListener();
    }
    ngAfterViewInit() {
        this.setNativeHTMLElements();
        this.setInitialFocus();
        this.setNumericInputIfPossible();
        this.handleDisable(this.isNgxOtpArrayDisabled);
    }
    ngOnDestroy() {
        this.ngxOtpArray$.unsubscribe();
    }
    clear() {
        var _a;
        this.removeStyleFromAll((_a = this.otpConfig.classList) === null || _a === void 0 ? void 0 : _a.inputFilled);
        this.ngxOtpArray.reset();
        this.ref.detectChanges();
        if (this.otpConfig.autofocus) {
            this.setFocus(0);
        }
    }
    handleKeyUp(index, value) {
        var _a;
        if (this.otpConfig.pattern.test(value) && value !== 'Backspace') {
            this.addStyle(index, (_a = this.otpConfig.classList) === null || _a === void 0 ? void 0 : _a.inputFilled);
            if (!this.ngxOtpArray.valid) {
                this.getFormControlByIndex(index).setValue(value);
                this.stepForward(index);
            }
            else {
                this.blur();
            }
        }
    }
    handleDelete(index) {
        var _a;
        this.removeStyle(index, (_a = this.otpConfig.classList) === null || _a === void 0 ? void 0 : _a.inputFilled);
        if ((this.otpConfig.behavior === NgxOtpBehavior.LEGACY &&
            !this.focusedInputHasValue) ||
            this.otpConfig.behavior !== NgxOtpBehavior.LEGACY) {
            this.stepBackward(index);
        }
        else {
            this.focusedInputHasValue = false;
        }
    }
    handleFocus(index) {
        this.focusedInputHasValue = !!this.ngxOtpArray.controls[index].value;
        if (this.otpConfig.behavior === NgxOtpBehavior.LEGACY &&
            this.focusedInputHasValue) {
            this.inputs[index].select();
        }
    }
    stepBackward(index) {
        if (index > 0) {
            this.setFocus(index - 1);
        }
    }
    stepForward(index) {
        if (index < this.LAST_INPUT_INDEX) {
            this.setFocus(index + 1);
        }
    }
    otpFormChangeListener() {
        this.ngxOtpArray$ = this.ngxOtpArray.valueChanges.subscribe((values) => {
            this.otpChange.emit(values);
            if (this.ngxOtpArray.valid) {
                this.fill.emit(values.join(''));
            }
        });
    }
    setUpOtpForm() {
        for (let i = 0; i < this.otpConfig.otpLength; i++) {
            this.ngxOtpArray.push(new UntypedFormControl(null, [Validators.required]));
        }
    }
    setUpAriaLabels() {
        const labels = this.otpConfig.ariaLabels;
        this.ariaLabels = Array.isArray(labels)
            ? labels
            : new Array(this.otpConfig.otpLength).fill(labels || this.DEFAULT_ARIA_LABEL);
    }
    setNativeHTMLElements() {
        this.inputs = this.otpInputElements.map((element) => element.nativeElement);
    }
    setInitialFocus() {
        if (this.otpConfig.autofocus) {
            this.setFocus(0);
        }
    }
    setInitialStyles() {
        this.styles = this.ngxOtpInputService.init2DArray(this.otpConfig.otpLength);
        this.addStyleToAll(this.otpConfig.classList.input);
    }
    setFocus(index) {
        this.inputs[index].focus();
    }
    setNumericInputIfPossible() {
        if (this.otpConfig.numericInputMode) {
            this.otpConfig.pattern = this.defaultPattern;
            this.inputs.map((element) => {
                element.setAttribute('inputmode', 'numeric');
                element.setAttribute('pattern', '[0-9]*');
            });
        }
    }
    blur() {
        if (this.otpConfig.autoblur) {
            this.inputs.map((input) => input.blur());
        }
    }
    handlePaste(value) {
        if (this.otpConfig.pattern.test(value)) {
            let lastIndex = 0;
            value
                .split('')
                .slice(0, this.otpConfig.otpLength)
                .map((character, index) => {
                var _a;
                this.addStyle(index, (_a = this.otpConfig.classList) === null || _a === void 0 ? void 0 : _a.inputFilled);
                this.getFormControlByIndex(index).setValue(character);
                lastIndex = index;
            });
            if (this.ngxOtpArray.valid) {
                this.blur();
            }
            else {
                this.setFocus(lastIndex + 1);
            }
        }
    }
    handleDisable(isDisabled) {
        var _a, _b;
        if (isDisabled) {
            this.ngxOtpArray.disable();
            this.addStyleToAll((_a = this.otpConfig.classList) === null || _a === void 0 ? void 0 : _a.inputDisabled);
        }
        else {
            this.ngxOtpArray.enable();
            this.removeStyleFromAll((_b = this.otpConfig.classList) === null || _b === void 0 ? void 0 : _b.inputDisabled);
        }
    }
    handleStatusChange(status) {
        var _a, _b, _c, _d;
        this.removeStyleFromAll([
            ...this.ngxOtpInputService.toArray((_a = this.otpConfig.classList) === null || _a === void 0 ? void 0 : _a.inputSuccess),
            ...this.ngxOtpInputService.toArray((_b = this.otpConfig.classList) === null || _b === void 0 ? void 0 : _b.inputError),
        ]);
        if (status) {
            if (status === 'success') {
                this.addStyleToAll((_c = this.otpConfig.classList) === null || _c === void 0 ? void 0 : _c.inputSuccess);
            }
            else if (status === 'error') {
                this.addStyleToAll((_d = this.otpConfig.classList) === null || _d === void 0 ? void 0 : _d.inputError);
            }
        }
    }
    getFormControlByIndex(index) {
        return this.ngxOtpArray.controls[index];
    }
    addStyle(index, styles) {
        this.styles = this.ngxOtpInputService.addItemAtIndex(this.styles, index, this.ngxOtpInputService.toArray(styles));
    }
    addStyleToAll(styles) {
        this.styles = this.ngxOtpInputService.addItemToAll(this.styles, this.ngxOtpInputService.toArray(styles));
    }
    removeStyle(index, styles) {
        this.styles = this.ngxOtpInputService.removeItemAtIndex(this.styles, index, this.ngxOtpInputService.toArray(styles));
    }
    removeStyleFromAll(styles) {
        this.styles = this.ngxOtpInputService.removeItemFromAll(this.styles, this.ngxOtpInputService.toArray(styles));
    }
}
NgxOtpInputComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputComponent, deps: [{ token: NgxOtpInputService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
NgxOtpInputComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.1", type: NgxOtpInputComponent, selector: "ngx-otp-input", inputs: { disable: "disable", config: "config", status: "status" }, outputs: { otpChange: "otpChange", fill: "fill" }, host: { listeners: { "paste": "onPaste($event)" } }, viewQueries: [{ propertyName: "otpInputElements", predicate: ["otpInputElement"], descendants: true }], ngImport: i0, template: "<form\n  [ngClass]=\"otpConfig.classList?.container\"\n  class=\"ngx-otp-input-container\"\n>\n  <div\n    *ngFor=\"let control of ngxOtpArray.controls; let i = index\"\n    [ngClass]=\"otpConfig.classList?.inputBox\"\n    class=\"ngx-otp-input-box\"\n  >\n    <label [attr.aria-label]=\"ariaLabels[i]\">\n      <input\n        #otpInputElement\n        [id]=\"'ngx-otp-input-' + i\"\n        [formControl]=\"control\"\n        [ngxOtpPattern]=\"otpConfig.pattern\"\n        [type]=\"otpConfig.isPasswordInput ? 'password' : 'text'\"\n          [ngClass]=\"styles?.length > 0 ? styles[i] : null\"\n        (keyup)=\"handleKeyUp(i, $event.key)\"\n        (keyup.backspace)=\"handleDelete(i)\"\n        (keyup.arrowLeft)=\"stepBackward(i)\"\n        (keyup.arrowRight)=\"stepForward(i)\"\n        (focus)=\"handleFocus(i)\"\n        class=\"ngx-otp-input\"\n        maxlength=\"1\"\n        autocapitalize=\"off\"\n        spellcheck=\"false\"\n      />\n    </label>\n  </div>\n</form>\n", styles: [".ngx-otp-input-container{display:flex}.ngx-otp-input-box{margin:0 5px}.ngx-otp-input-box:first-child{margin-left:0}.ngx-otp-input-box:last-child{margin-right:0}.ngx-otp-input{width:35px;height:35px;text-align:center;font-size:1.25rem;border:1px solid #212121;border-radius:4px;outline:0}.ngx-otp-input-disabled{opacity:.3}\n"], dependencies: [{ kind: "directive", type: i2.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { kind: "directive", type: i2.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i2.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: PatternDirective, selector: "[ngxOtpPattern]", inputs: ["ngxOtpPattern"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-otp-input', changeDetection: ChangeDetectionStrategy.OnPush, template: "<form\n  [ngClass]=\"otpConfig.classList?.container\"\n  class=\"ngx-otp-input-container\"\n>\n  <div\n    *ngFor=\"let control of ngxOtpArray.controls; let i = index\"\n    [ngClass]=\"otpConfig.classList?.inputBox\"\n    class=\"ngx-otp-input-box\"\n  >\n    <label [attr.aria-label]=\"ariaLabels[i]\">\n      <input\n        #otpInputElement\n        [id]=\"'ngx-otp-input-' + i\"\n        [formControl]=\"control\"\n        [ngxOtpPattern]=\"otpConfig.pattern\"\n        [type]=\"otpConfig.isPasswordInput ? 'password' : 'text'\"\n          [ngClass]=\"styles?.length > 0 ? styles[i] : null\"\n        (keyup)=\"handleKeyUp(i, $event.key)\"\n        (keyup.backspace)=\"handleDelete(i)\"\n        (keyup.arrowLeft)=\"stepBackward(i)\"\n        (keyup.arrowRight)=\"stepForward(i)\"\n        (focus)=\"handleFocus(i)\"\n        class=\"ngx-otp-input\"\n        maxlength=\"1\"\n        autocapitalize=\"off\"\n        spellcheck=\"false\"\n      />\n    </label>\n  </div>\n</form>\n", styles: [".ngx-otp-input-container{display:flex}.ngx-otp-input-box{margin:0 5px}.ngx-otp-input-box:first-child{margin-left:0}.ngx-otp-input-box:last-child{margin-right:0}.ngx-otp-input{width:35px;height:35px;text-align:center;font-size:1.25rem;border:1px solid #212121;border-radius:4px;outline:0}.ngx-otp-input-disabled{opacity:.3}\n"] }]
        }], ctorParameters: function () { return [{ type: NgxOtpInputService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { otpInputElements: [{
                type: ViewChildren,
                args: ['otpInputElement']
            }], otpChange: [{
                type: Output
            }], fill: [{
                type: Output
            }], onPaste: [{
                type: HostListener,
                args: ['paste', ['$event']]
            }], disable: [{
                type: Input
            }], config: [{
                type: Input
            }], status: [{
                type: Input
            }] } });

class NgxOtpInputModule {
}
NgxOtpInputModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxOtpInputModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputModule, declarations: [NgxOtpInputComponent, PatternDirective], imports: [ReactiveFormsModule, FormsModule, CommonModule], exports: [NgxOtpInputComponent] });
NgxOtpInputModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputModule, providers: [NgxOtpInputService], imports: [ReactiveFormsModule, FormsModule, CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.1", ngImport: i0, type: NgxOtpInputModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgxOtpInputComponent, PatternDirective],
                    imports: [ReactiveFormsModule, FormsModule, CommonModule],
                    exports: [NgxOtpInputComponent],
                    providers: [NgxOtpInputService],
                }]
        }] });

/*
 * Public API Surface of ngx-otp-input
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxOtpBehavior, NgxOtpInputComponent, NgxOtpInputModule };
//# sourceMappingURL=ngx-otp-input.mjs.map
